---
name: strategic-compact
description: 任意の自動コンパクションではなく、論理的なインターバルでの手動コンテキストコンパクションを提案し、タスクフェーズ間でコンテキストを保持します。
---

# Strategic Compact Skill

任意の自動コンパクションに頼るのではなく、ワークフローの戦略的なポイントで手動 `/compact` を提案します。

## なぜ戦略的コンパクションなのか？

自動コンパクションは任意のポイントでトリガーされます:
- しばしばタスクの途中で発生し、重要なコンテキストが失われる
- 論理的なタスク境界を認識しない
- 複雑なマルチステップ操作を中断する可能性がある

論理的な境界での戦略的コンパクション:
- **探索後、実行前** - リサーチコンテキストをコンパクト化し、実装計画を保持
- **マイルストーン完了後** - 次のフェーズのために新鮮なスタート
- **大きなコンテキストシフト前** - 異なるタスクの前に探索コンテキストをクリア

## 動作の仕組み

`suggest-compact.sh` スクリプトは PreToolUse (Edit/Write) で実行され:

1. **ツール呼び出しを追跡** - セッション内のツール呼び出しをカウント
2. **閾値検出** - 設定可能な閾値（デフォルト: 50回の呼び出し）で提案
3. **定期的なリマインダー** - 閾値後、25回の呼び出しごとにリマインド

## Hook の設定

`~/.claude/settings.json` に追加:

```json
{
  "hooks": {
    "PreToolUse": [{
      "matcher": "tool == \"Edit\" || tool == \"Write\"",
      "hooks": [{
        "type": "command",
        "command": ".claude/skills/strategic-compact/suggest-compact.sh"
      }]
    }]
  }
}
```

## 設定

環境変数:
- `COMPACT_THRESHOLD` - 最初の提案前のツール呼び出し数（デフォルト: 50）

## ベストプラクティス

1. **計画後にコンパクト** - 計画が確定したら、新鮮に開始するためにコンパクト
2. **デバッグ後にコンパクト** - エラー解決コンテキストをクリアしてから続行
3. **実装中はコンパクトしない** - 関連する変更のためにコンテキストを保持
4. **提案を読む** - Hook は「いつ」を教えてくれるが、「するかどうか」はあなたが決める

## 関連

- Memory persistence hooks - コンパクション後も生き残る状態のため
